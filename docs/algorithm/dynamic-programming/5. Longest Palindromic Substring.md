# 5. Longest Palindromic Substring

## 状态转移方程初始化

### 如果字串$S_{i}...S_{j}$是回文字串

$$
P(i,j)=
\begin{cases}
true\text{如果字串}S_{i}...S_{j}\text{是回文字串} \\
false\text{其他情况}
\end{cases}
$$

$$
P(i,i)=true
$$

$$
P(i,i+1)=(S_i==S_{i+1})
$$

## 状态转移方程

$$
P(i,j)=P(i+1,j−1)\land(S_i==S_j)
$$

```ts
function longestPalindrome(s: string): string {
    const length = s.length
    const dp = Array.from({ length }, () => Array.from({ length }));
    // f(start, end) = f(start-1, end-1) && s[start] === s[end];

    // f(subLength = 1)
    for (let i = 0; i <= dp.length - 1; i++) {
        dp[i][i] = true;
    }

    // f(subLength = 2)
    for (let i = 0; i <= dp.length - 2; i++) {
        dp[i][i + 1] = s[i] === s[i + 1]
    }

    // f(subLength >= 3)
    for (let subLength = 3; subLength <= dp.length; subLength++) {
        for (let i = 0; i <= dp.length - subLength; i++) {
            dp[i][i + subLength - 1] = dp[i + 1][i + subLength - 2] && (s[i] === s[i + subLength - 1])
        }
    }

    let start = 0;
    let end = 0;
    for (let i = 0; i <= length - 1; i++) {
        for (let j = i + 1; j <= length - 1; j++) {
            if (dp[i][j]) {
                if ((j - i) > (end - start)) {
                    start = i;
                    end = j;
                }
            }
        }
    }

    return s.substring(start, end + 1)
};

```
